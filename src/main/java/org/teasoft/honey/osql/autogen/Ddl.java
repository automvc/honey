/*
 * Copyright 2016-2021 the original author.All rights reserved.
 * Kingstar(honeysoft@126.com)
 * The license,see the LICENSE file.
 */

package org.teasoft.honey.osql.autogen;

import org.teasoft.bee.osql.PreparedSql;
import org.teasoft.bee.osql.SuidRich;
import org.teasoft.bee.osql.exception.BeeErrorNameException;
import org.teasoft.honey.osql.core.BeeFactoryHelper;
import org.teasoft.honey.osql.core.HoneyConfig;
import org.teasoft.honey.osql.core.HoneyUtil;
import org.teasoft.honey.osql.core.Logger;
import org.teasoft.honey.osql.core.NameTranslateHandle;
import org.teasoft.honey.osql.name.NameUtil;
import org.teasoft.honey.osql.shortcut.BF;
import org.teasoft.honey.osql.util.NameCheckUtil;
import org.teasoft.honey.util.SqlKeyCheck;
import org.teasoft.honey.util.StringUtils;

/**
 * 根据Javabean创建表.Create table according to Javabean
 * @author Kingstar
 * @since  1.9
 */
public class Ddl {

	private static PreparedSql preparedSql = BeeFactoryHelper.getPreparedSql();
	private static SuidRich suidRich = BF.getSuidRich();

	private Ddl() {}
	
	/**
	 * @param entityClass
	 * @return
	 * @since 2.0
	 */
	public static <T> boolean createTable(Class<T> entityClass) {
		return createTable(entityClass, false);
	}
	
	/**
	 * @param entityClass
	 * @param isDropExistTable
	 * @return
	 * @since 2.0
	 */
	public static <T> boolean createTable(Class<T> entityClass, boolean isDropExistTable) {
		return suidRich.createTable(entityClass, isDropExistTable);
		
	}

	/**
	 * 根据Javabean生成数据库表,Javabean无需配置过多的字段信息.此方法只考虑通用情况,若有详细需求,不建议采用
	 * <br>According to the database table generated by JavaBean, JavaBean does not need to configure 
	 * <br>too much field information. This method only considers the general situation, and is not 
	 * <br>recommended if there are detailed requirements.
	 * @param entity Javabean entity.
	 * @return flag whether create successfully.
	 * @deprecated
	 */
	public static <T> boolean createTable(T entity) {
		return createTable(entity, false);
	}
	
	/**
	 * 
	 * @param entity
	 * @param isDropExistTable
	 * @return
	 * @deprecated
	 */
	public static <T> boolean createTable(T entity, boolean isDropExistTable) {
		if (isDropExistTable) {
			String tableName = _toTableName(entity);
			boolean second = false;
			try {
				String sql0 = "";

				if (HoneyUtil.isOracle() || HoneyUtil.isSqlServer()) {
					sql0 = "DROP TABLE " + tableName;
				} else {
					sql0 = " DROP TABLE IF EXISTS " + tableName;
					second = true;
				}
				preparedSql.modify(sql0);
			} catch (Exception e) {
				if (second) {
					try {
						preparedSql.modify("DROP TABLE " + tableName);
					} catch (Exception e2) {
						Logger.warn(e2.getMessage());
					}
				}
			}
			return _createTable(entity, tableName);

		} else {// donot Drop ExistTable
			if (isExistTable(entity)) return true; // V1.17 已存在,则不创建
			return _createTable(entity,null);
		}

	}

	/**
	 * check whether the table exist or not.
	 * @param entity
	 * @return if exist true, otherwise false.
	 * @since 1.17
	 */
	public static <T> boolean isExistTable(T entity) {
		boolean flag = false;
		try {
			suidRich.select(entity, 1);
			flag = true;
			String tableName = _toTableName(entity);
			Logger.warn("The database exist the table : " + tableName);
		} catch (Exception e) {

		}
		return flag;
	}

	private static <T> boolean _createTable(T entity, String tableName) {
		boolean result = false;
		try {
			ddlModify(DdlToSql.toCreateTableSQL(entity.getClass(), tableName));
			result = true;
		} catch (Exception e) {
			Logger.error(e.getMessage(), e);
			result = false;
		}

		return result;
	}

	@SuppressWarnings("deprecation")
	private static void ddlModify(String sql) {
		// V1.11 创建语句的可执行语句与占位的是一样的,无需要重复输出.
		boolean old = HoneyConfig.getHoneyConfig().showSql_showExecutableSql;
		if (old) HoneyConfig.getHoneyConfig().showSql_showExecutableSql = false;
		preparedSql.modify(sql);
		if (old) HoneyConfig.getHoneyConfig().showSql_showExecutableSql = old;
	}


	public static void setDynamicParameter(String para, String value) {
		BeeFactoryHelper.getSuid().setDynamicParameter(para, value);
	}

	private static String _toTableName(Object entity) {
		return NameTranslateHandle.toTableName(NameUtil.getClassFullName(entity));
	}

	@SuppressWarnings("rawtypes")
	private static String _toColumnName(String fieldName, Class entityClass) {
		String name = NameTranslateHandle.toColumnName(fieldName, entityClass);
		if (SqlKeyCheck.isKeyWord(name)) {
			Logger.warn("The '" + name + "' is Sql Keyword. Do not recommend!");
		}
		return name;
	}

	/**
	 * 创建通用索引.create normal index
	 * @param entity table's entity(do not allow null).
	 * @param fields  field name,if more than one,separate with comma.
	 */
	public static <T> void indexNormal(T entity, String fields) {
		indexNormal(entity, fields, null);
	}

	/**
	 * 创建通用索引.create normal index
	 * @param entity table's entity(do not allow null).
	 * @param fields  field name,if more than one,separate with comma.
	 * @param indexName  index name
	 */
	public static <T> void indexNormal(T entity, String fields, String indexName) {
//		String PREFIX = "idx_";
//		String IndexTypeTip = "normal";
//		String IndexType = ""; //normal will empty
//
//		if (StringUtils.isBlank(fields)) {
//			throw new BeeErrorNameException(
//					"Create " + IndexTypeTip + " index, the fields can not be empty!");
//		}
//		checkField(fields);
//		String tableName = _toTableName(entity);
//
//		String columns = transferField(fields, entity.getClass());
//
//		if (StringUtils.isBlank(indexName)) {
//			indexName = PREFIX + tableName + "_" + columns.replace(",", "_");
//		}
//
//		String indexSql = "CREATE "+IndexType+"INDEX " + indexName + " ON " + tableName + "(" + columns
//				+ ")";
//		ddlModify(indexSql);

		String PREFIX = "idx_";
		String IndexTypeTip = "normal";
		String IndexType = ""; // normal will empty
		_index(entity, fields, indexName, PREFIX, IndexTypeTip, IndexType);
	}

	private static String transferField(String fields, Class c) {
		String str[] = fields.split(",");
		String columns = "";
		for (int i = 0; i < str.length; i++) {
			if (i != 0) columns += ",";
			columns += _toColumnName(str[i].trim(), c);
		}

		return columns;
	}

	private static void checkField(String fields) {
		NameCheckUtil.checkName(fields);
	}

	/**
	 * 创建唯一索引.create unique index
	 * @param entity table's entity(do not allow null).
	 * @param fields  field name,if more than one,separate with comma.
	 */
	public static <T> void unique(T entity, String fields) {
		unique(entity, fields, null);
	}

	/**
	 * 创建唯一索引.create unique index
	 * @param entity table's entity(do not allow null).
	 * @param fields  field name,if more than one,separate with comma.
	 * @param indexName  index name
	 */
	public static <T> void unique(T entity, String fields, String indexName) {
		String PREFIX = "uie_";
		String IndexTypeTip = "unique";
		String IndexType = "UNIQUE "; // 后面有一个空格
		_index(entity, fields, indexName, PREFIX, IndexTypeTip, IndexType);
	}

	private static <T> void _index(T entity, String fields, String indexName, String PREFIX,
			String IndexTypeTip, String IndexType) {
//		String PREFIX = "idx_";
//		String IndexTypeTip = "normal";
//		String IndexType = ""; //normal will empty

		if (StringUtils.isBlank(fields)) {
			throw new BeeErrorNameException(
					"Create " + IndexTypeTip + " index, the fields can not be empty!");
		}
		checkField(fields);
		String tableName = _toTableName(entity);

		String columns = transferField(fields, entity.getClass());

		if (StringUtils.isBlank(indexName)) {
			indexName = PREFIX + tableName + "_" + columns.replace(",", "_");
		} else {
			checkField(indexName);
		}

		String indexSql = "CREATE " + IndexType + "INDEX " + indexName + " ON " + tableName
				+ "(" + columns + ")";
		ddlModify(indexSql);
	}

//	

	public static <T> void primaryKey(T entity, String fields) {
		primaryKey(entity, fields, null);
	}

	/**
	 * 创建主键,一般是多字段联合主键.create primary key
	 * @param entity table's entity(do not allow null).
	 * @param fields  field name,if more than one,separate with comma.
	 * @param keyName  key name
	 */
	public static <T> void primaryKey(T entity, String fields, String keyName) {
//		alter table tableName add constraint pk_name primary key (id,pid) --添加主键约束

		String PREFIX = "pk_";
		String typeTip = "normal";

		if (StringUtils.isBlank(fields)) {
			throw new BeeErrorNameException(
					"Create " + typeTip + " index, the fields can not be empty!");
		}
		checkField(fields);
		String tableName = _toTableName(entity);

		String columns = transferField(fields, entity.getClass());

		if (StringUtils.isBlank(keyName)) {
			keyName = PREFIX + tableName + "_" + columns.replace(",", "_");
		} else {
			checkField(keyName);
		}

		String indexSql = "ALTER TABLE " + tableName + " ADD CONSTRAINT " + keyName
				+ " PRIMARY KEY (" + columns + ")";
		ddlModify(indexSql);
	}
}
